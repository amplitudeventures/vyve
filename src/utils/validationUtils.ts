import { formatLogObject } from './logUtils';

export interface AnalysisValidationResult {
  isValid: boolean;
  discrepancies: string[];
  recommendation: string;
  metrics: {
    contentLength: number;
    keywordMatches: number;
    contextCoverage: number;
    semanticSimilarity: number;
  };
}

interface ValidationOptions {
  minContentLength?: number;
  requiredKeywords?: string[];
  contextImportance?: number;
  semanticThreshold?: number;
}

const DEFAULT_OPTIONS: ValidationOptions = {
  minContentLength: 100,
  requiredKeywords: [],
  contextImportance: 0.7,
  semanticThreshold: 0.6
};

/**
 * Validates the quality and completeness of analysis output relative to its original input context.
 * 
 * @param analysisOutput - The text generated by the analysis
 * @param originalContext - The original input context used to generate the analysis
 * @param options - Optional validation configuration
 * @returns AnalysisValidationResult with validation details
 */
export function validateAnalysisOutput(
  analysisOutput: string,
  originalContext: string,
  options: ValidationOptions = {}
): AnalysisValidationResult {
  const mergedOptions = { ...DEFAULT_OPTIONS, ...options };
  const discrepancies: string[] = [];
  
  // Initialize metrics
  const metrics = {
    contentLength: analysisOutput.length,
    keywordMatches: 0,
    contextCoverage: 0,
    semanticSimilarity: 0
  };

  // 1. Content Length Check
  if (analysisOutput.length < mergedOptions.minContentLength!) {
    discrepancies.push(`Content length (${analysisOutput.length}) is below minimum threshold (${mergedOptions.minContentLength})`);
  }

  // 2. Keyword Verification
  if (mergedOptions.requiredKeywords!.length > 0) {
    const foundKeywords = mergedOptions.requiredKeywords!.filter(keyword => 
      analysisOutput.toLowerCase().includes(keyword.toLowerCase())
    );
    metrics.keywordMatches = foundKeywords.length;
    
    const missingKeywords = mergedOptions.requiredKeywords!.filter(keyword => 
      !analysisOutput.toLowerCase().includes(keyword.toLowerCase())
    );
    
    if (missingKeywords.length > 0) {
      discrepancies.push(`Missing required keywords: ${missingKeywords.join(', ')}`);
    }
  }

  // 3. Context Coverage Analysis
  const contextWords = new Set(originalContext.toLowerCase().split(/\s+/));
  const outputWords = new Set(analysisOutput.toLowerCase().split(/\s+/));
  const commonWords = new Set([...outputWords].filter(word => contextWords.has(word)));
  
  metrics.contextCoverage = commonWords.size / contextWords.size;
  
  if (metrics.contextCoverage < mergedOptions.contextImportance!) {
    discrepancies.push(`Low context coverage (${(metrics.contextCoverage * 100).toFixed(1)}%)`);
  }

  // 4. Basic Semantic Similarity (using word overlap as a simple metric)
  const contextTokens = originalContext.toLowerCase().split(/\s+/);
  const outputTokens = analysisOutput.toLowerCase().split(/\s+/);
  
  const commonTokens = outputTokens.filter(token => contextTokens.includes(token));
  metrics.semanticSimilarity = commonTokens.length / Math.max(contextTokens.length, outputTokens.length);
  
  if (metrics.semanticSimilarity < mergedOptions.semanticThreshold!) {
    discrepancies.push(`Low semantic similarity (${(metrics.semanticSimilarity * 100).toFixed(1)}%)`);
  }

  // Log validation results
  console.log('[ValidationUtils] Analysis validation results:', formatLogObject({
    metrics,
    discrepanciesCount: discrepancies.length,
    timestamp: new Date().toISOString()
  }));

  // Generate recommendation based on validation results
  const recommendation = generateRecommendation(discrepancies, metrics);

  return {
    isValid: discrepancies.length === 0,
    discrepancies,
    recommendation,
    metrics
  };
}

function generateRecommendation(
  discrepancies: string[],
  metrics: AnalysisValidationResult['metrics']
): string {
  if (discrepancies.length === 0) {
    return 'Analysis output meets all quality standards.';
  }

  const recommendations: string[] = [];

  if (metrics.contentLength < DEFAULT_OPTIONS.minContentLength!) {
    recommendations.push('Consider requesting a more detailed analysis');
  }
  
  if (metrics.contextCoverage < DEFAULT_OPTIONS.contextImportance!) {
    recommendations.push('Analysis may need to better incorporate context');
  }
  
  if (metrics.semanticSimilarity < DEFAULT_OPTIONS.semanticThreshold!) {
    recommendations.push('Analysis might need better alignment with input context');
  }

  return recommendations.length > 0
    ? `Recommended actions: ${recommendations.join('; ')}.`
    : 'Review the identified discrepancies and consider adjusting the analysis parameters.';
}

export function validateMessage(message: any): boolean {
  if (!message || typeof message !== 'object') return false;
  if (!message.role || typeof message.role !== 'string') return false;
  if (message.content === undefined || message.content === null) return false;
  if (typeof message.content !== 'string') return false;
  return message.content.trim().length > 0;
}

export function validateMessages(messages: any[]): { 
  isValid: boolean; 
  error?: string;
} {
  if (!Array.isArray(messages)) {
    return { isValid: false, error: 'Messages must be an array' };
  }

  if (messages.length === 0) {
    return { isValid: false, error: 'Messages array cannot be empty' };
  }

  for (const message of messages) {
    if (!validateMessage(message)) {
      return { 
        isValid: false, 
        error: `Invalid message: ${JSON.stringify(message)}` 
      };
    }
  }

  return { isValid: true };
} 