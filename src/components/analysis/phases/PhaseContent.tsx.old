import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Loader2, PlayCircle, FileText, CheckCircle, AlertCircle, Code, Sparkles, MessageSquare, RefreshCw } from "lucide-react";
import { PhaseConfig } from "@/types/vyve";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from "@/components/ui/collapsible";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { useState, useEffect } from "react";
import { supabase } from "@/integrations/supabase/client";
import { cn } from "@/lib/utils";
import { Textarea } from "@/components/ui/textarea";
import { toast } from "@/components/ui/use-toast";
import { Progress } from "@/components/ui/progress";

interface PhaseContentProps {
  phaseData: PhaseConfig;
  onStart: (model: string) => void;
  onUpdate?: (updatedPhaseData: PhaseConfig) => void;
}

const ADJUSTMENT_SYSTEM_PROMPT = `You are an AI assistant helping to refine and adjust the analysis results based on user feedback.
Your task is to maintain the context and knowledge from the original analysis while incorporating the user's specific requests for adjustments.

Guidelines:
- Preserve the key insights and findings from the original analysis
- Focus on the specific areas the user wants to elaborate on or modify
- Maintain the same level of expertise and analytical depth
- Keep the style consistent with the original analysis
- Include any new perspectives or angles requested by the user
- If the user asks for more examples or elaboration, provide them while maintaining relevance
- Ensure the adjusted response flows naturally and doesn't feel disconnected from the original analysis

The response should feel like a natural evolution of the original analysis, not a separate or disconnected piece.`;

// Update the DEFAULT_ANALYSIS_STEPS to be more detailed
const DEFAULT_ANALYSIS_STEPS = [
  { 
    step: 'Initial Setup',
    description: 'Preparing analysis environment',
    status: 'pending',
    timestamp: new Date().toISOString(),
    order: 0
  },
  { 
    step: 'Document Retrieval',
    description: 'Loading and processing documents',
    status: 'pending',
    timestamp: new Date().toISOString(),
    order: 1
  },
  { 
    step: 'Pinecone Query',
    description: 'Finding relevant document sections',
    status: 'pending',
    timestamp: new Date().toISOString(),
    order: 2
  },
  { 
    step: 'Framework Analysis',
    description: 'Analyzing content structure',
    status: 'pending',
    timestamp: new Date().toISOString(),
    order: 3
  },
  { 
    step: 'OpenAI Analysis',
    description: 'Generating detailed insights',
    status: 'pending',
    timestamp: new Date().toISOString(),
    order: 4
  },
  { 
    step: 'Format Verification',
    description: 'Validating analysis format',
    status: 'pending',
    timestamp: new Date().toISOString(),
    order: 5
  },
  { 
    step: 'Final Verification',
    description: 'Checking analysis quality',
    status: 'pending',
    timestamp: new Date().toISOString(),
    order: 6
  },
  { 
    step: 'Saving Results',
    description: 'Storing analysis results',
    status: 'pending',
    timestamp: new Date().toISOString(),
    order: 7
  }
];

export function PhaseContent({ phaseData, onStart, onUpdate }: PhaseContentProps) {
  const { name, description, prompt, documents, status, error, result } = phaseData;
  const [selectedModel, setSelectedModel] = useState<string>(() => {
    // Try to get the last selected model from localStorage, default to 'deepseek-reasoner' if not found
    return localStorage.getItem('selectedModel') || 'deepseek-reasoner';
  });
  const [adjustmentText, setAdjustmentText] = useState('');
  const [isAdjusting, setIsAdjusting] = useState(false);

  // Add proper null check for result
  const hasContent = result?.content && result.content.length > 0;

  // Modify the polling effect to initialize steps immediately
  useEffect(() => {
    let pollInterval: NodeJS.Timeout;
    let isPolling = false;
    
    // Initialize steps immediately when status changes to in_progress
    if (status === 'in_progress' && onUpdate) {
      // Initialize with first step in progress
      const initialSteps = DEFAULT_ANALYSIS_STEPS.map((step, index) => ({
        ...step,
        status: index === 0 ? 'in_progress' : 'pending',
        timestamp: new Date().toISOString()
      }));

      onUpdate({
        ...phaseData,
        status: 'in_progress',
        result: {
          ...phaseData.result,
          phase_number: phaseData.phase,
          content: '',
          created_at: new Date().toISOString(),
          metadata: {
            ...phaseData.result?.metadata,
            status: 'in_progress',
            conversation_log: initialSteps
          }
        }
      });
    }

    if (status === 'in_progress') {
      pollInterval = setInterval(async () => {
        if (isPolling) return;
        
        try {
          isPolling = true;
          
          const { data, error } = await supabase
            .from('analysis_results')
            .select('*')
            .eq('phase_number', phaseData.phase)
            .order('created_at', { ascending: false })
            .limit(1);
          
          if (error) {
            console.error('Error polling for updates:', error);
            return;
          }

          const latestResult = data?.[0];
          if (!latestResult) return;

          // Get current steps or use initialized steps
          let currentSteps = latestResult.metadata?.conversation_log || [...DEFAULT_ANALYSIS_STEPS];
          
          // Ensure all steps exist
          if (currentSteps.length < DEFAULT_ANALYSIS_STEPS.length) {
            currentSteps = [
              ...currentSteps,
              ...DEFAULT_ANALYSIS_STEPS.slice(currentSteps.length)
            ];
          }

          // Find current in-progress step
          const currentStepIndex = currentSteps.findIndex(s => s.status === 'in_progress');
          
          // Update step progress based on content and validation
          if (currentStepIndex !== -1 && latestResult.content) {
            if (typeof latestResult.content === 'string' && latestResult.content.trim()) {
              // Complete current step
              currentSteps[currentStepIndex] = {
                ...currentSteps[currentStepIndex],
                status: 'completed',
                timestamp: new Date().toISOString()
              };

              // Start next step if available
              if (currentStepIndex < currentSteps.length - 1) {
                currentSteps[currentStepIndex + 1] = {
                  ...currentSteps[currentStepIndex + 1],
                  status: 'in_progress',
                  timestamp: new Date().toISOString()
                };
              }
            }
          }

          // Handle errors with more detail
          if (latestResult.metadata?.status === 'error') {
            const errorStepIndex = currentSteps.findIndex(s => s.status === 'in_progress');
            if (errorStepIndex !== -1) {
              currentSteps[errorStepIndex] = {
                ...currentSteps[errorStepIndex],
                status: 'error',
                details: {
                  error: latestResult.metadata?.error || 'Unknown error occurred',
                  timestamp: new Date().toISOString()
                }
              };
            }
          }

          // Update phase data with current progress
          const updatedPhaseData = {
            ...phaseData,
            status: latestResult.metadata?.status === 'completed' ? 'completed' as const : 'in_progress' as const,
            result: {
              phase_number: latestResult.phase_number,
              content: latestResult.content || '',
              created_at: latestResult.created_at,
              metadata: {
                ...latestResult.metadata,
                conversation_log: currentSteps,
                lastContent: latestResult.content,
                lastUpdate: new Date().toISOString()
              }
            }
          };

          onUpdate?.(updatedPhaseData);

          // Clear interval if complete or error
          if (latestResult.metadata?.status === 'completed' || latestResult.metadata?.status === 'error') {
            clearInterval(pollInterval);
          }

        } catch (err) {
          console.error('Error polling for updates:', err);
        } finally {
          isPolling = false;
        }
      }, 1000);
    }

    return () => {
      if (pollInterval) {
        clearInterval(pollInterval);
      }
    };
  }, [status, phaseData, onUpdate]);

  // Add useEffect for logging
  useEffect(() => {
    if (status === 'completed' && result?.content) {
      console.log('Analysis completed - Summary:', {
        phase: name,
        status,
        resultLength: result.content.length,
        hasMetadata: !!result.metadata,
        keyFindings: result.metadata?.key_findings?.length || 0,
        recommendations: result.metadata?.recommendations?.length || 0
      });
      
      // Log complete content separately
      console.log('Complete analysis content:');
      console.log(result.content);
      
      console.log('Complete metadata:');
      console.log(JSON.stringify(result.metadata, null, 2));
    }
  }, [status, result, name]);

  // Update localStorage when model changes
  const handleModelChange = (model: string) => {
    console.log('Model changed:', { from: selectedModel, to: model });
    setSelectedModel(model);
    localStorage.setItem('selectedModel', model);
  };

  // Update the status when adjusting
  useEffect(() => {
    if (isAdjusting && onUpdate) {
      onUpdate({
        ...phaseData,
        status: 'in_progress',
        result: result ? {
          ...result,
          metadata: {
            ...result.metadata,
            status: 'in_progress',
            conversation_log: [
              ...(result.metadata?.conversation_log || []),
              {
                step: 'Applying Adjustments',
                status: 'in_progress',
                timestamp: new Date().toISOString(),
                details: {
                  model: selectedModel,
                  type: 'adjustment'
                }
              }
            ]
          }
        } : undefined
      });
    }
  }, [isAdjusting]);

  const handleAdjustment = async () => {
    if (!adjustmentText.trim() || !result?.content) {
      console.warn('[PhaseContent] Adjustment text is empty or no result content available');
      toast({
        title: "Cannot adjust analysis",
        description: "Please ensure there is analysis content to adjust and you've provided adjustment text.",
        variant: "destructive"
      });
      return;
    }

    setIsAdjusting(true);
    console.log('[PhaseContent] Starting adjustment process:', {
      phaseName: phaseData.name,
      model: selectedModel,
      timestamp: new Date().toISOString()
    });

    try {
      const adjustmentContext = {
        original_content: result.content,
        key_findings: result.metadata?.key_findings || [],
        phase_name: phaseData.name,
        phase_description: phaseData.description,
        user_adjustment: adjustmentText
      };

      const response = await fetch('/api/vyve/adjust-analysis', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: selectedModel,
          system_prompt: ADJUSTMENT_SYSTEM_PROMPT,
          context: adjustmentContext,
        }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Failed to apply adjustments: ${response.status} ${response.statusText}`);
      }

      const adjustedResult = await response.json();

      // Update the phase data with the adjusted results
      if (result && onUpdate) {
        onUpdate({
          ...phaseData,
          status: 'completed',
          result: {
            ...result,
            content: adjustedResult.content || result.content,
            metadata: {
              ...result.metadata,
              status: 'completed',
              adjustments: [
                ...(result.metadata?.adjustments || []),
                {
                  timestamp: new Date().toISOString(),
                  prompt: adjustmentText,
                  model: selectedModel
                }
              ],
              key_findings: adjustedResult.key_findings || result.metadata?.key_findings,
              conversation_log: [
                ...(result.metadata?.conversation_log || []),
                {
                  step: 'Applying Adjustments',
                  status: 'completed',
                  timestamp: new Date().toISOString(),
                  details: {
                    model: selectedModel,
                    type: 'adjustment',
                    contentLength: adjustedResult.content?.length,
                    findingsCount: adjustedResult.key_findings?.length
                  }
                }
              ]
            }
          }
        });
      }

      // Clear the adjustment text after successful application
      setAdjustmentText('');
      
      // Show success toast
      toast({
        title: "Adjustments Applied",
        description: "The analysis has been updated based on your feedback.",
      });

    } catch (err) {
      console.error('[PhaseContent] Error applying adjustments:', err);
      
      // Update status to error
      if (onUpdate) {
        onUpdate({
          ...phaseData,
          status: 'error',
          error: err instanceof Error ? err.message : 'Failed to apply adjustments'
        });
      }

      toast({
        title: "Error",
        description: err instanceof Error ? err.message : "Failed to apply adjustments. Please try again.",
        variant: "destructive",
      });
    } finally {
      setIsAdjusting(false);
    }
  };

  // Update renderStatus to show more details
  const renderStatus = () => {
    if (status === 'completed' && result?.content) {
      return (
        <div className="mt-6 space-y-4">
          <div className="prose max-w-none dark:prose-invert">
            <pre className="whitespace-pre-wrap">{result.content}</pre>
          </div>
        </div>
      );
    }

    if (status === 'in_progress') {
      const steps = result?.metadata?.conversation_log || DEFAULT_ANALYSIS_STEPS;
      
      const totalSteps = steps.length;
      const completedSteps = steps.filter(log => log.status === 'completed').length;
      const inProgressSteps = steps.filter(log => log.status === 'in_progress').length;
      const progress = totalSteps > 0 ? ((completedSteps + (inProgressSteps * 0.5)) / totalSteps) * 100 : 0;

      return (
        <div className="mt-6 space-y-4">
          <div className="flex items-center gap-4">
            <div className="flex-1">
              <Progress value={progress} className="h-2" />
            </div>
            <span className="text-sm text-muted-foreground whitespace-nowrap">
              {completedSteps}/{totalSteps} steps
            </span>
          </div>
          
          <div className="space-y-2">
            {steps.map((log, index) => (
              <div key={index} className="flex items-center gap-3 p-2 rounded-md hover:bg-muted/50">
                <div className="w-5 flex-shrink-0">
                  {log.status === 'completed' && <CheckCircle className="h-4 w-4 text-green-500" />}
                  {log.status === 'in_progress' && <Loader2 className="h-4 w-4 animate-spin text-blue-500" />}
                  {log.status === 'pending' && <div className="h-4 w-4 rounded-full border border-muted" />}
                  {log.status === 'error' && <AlertCircle className="h-4 w-4 text-red-500" />}
                </div>
                <div className="flex-1 min-w-0">
                  <div className="flex flex-col">
                    <span className="text-sm font-medium">
                      {log.step}
                    </span>
                    <span className="text-xs text-muted-foreground">
                      {log.description}
                    </span>
                  </div>
                  {log.details && (
                    <div className="mt-1">
                      <span className="text-xs text-muted-foreground">
                        {Object.entries(log.details)
                          .filter(([key]) => !['type', 'error'].includes(key))
                          .map(([key, value]) => `${key}: ${value}`)
                          .join(', ')}
                      </span>
                    </div>
                  )}
                  {log.status === 'error' && log.details?.error && (
                    <p className="text-xs text-red-400 mt-1">
                      {log.details.error}
                    </p>
                  )}
                </div>
              </div>
            ))}
          </div>
        </div>
      );
    }
    return null;
  };

  return (
    <Card className="mt-8 card-glow-subtle glass">
      <CardHeader className="space-y-4">
        <div className="flex items-center gap-3">
          <div className="relative group">
            <div className="absolute -inset-[1px] bg-gradient-to-r from-blue-500/30 via-purple-500/30 to-pink-500/30 rounded-xl opacity-50 blur group-hover:opacity-70 transition-opacity" />
            <div className="relative w-11 h-11 rounded-xl bg-background/90 backdrop-blur-sm flex items-center justify-center">
              <Sparkles className="h-5 w-5 text-blue-400/80 group-hover:text-blue-300 transition-colors" />
            </div>
          </div>
          <div>
            <CardTitle className="text-2xl bg-clip-text text-transparent bg-gradient-to-r from-blue-400/80 via-purple-400/80 to-pink-400/80">
              {name}
            </CardTitle>
            <CardDescription className="text-lg text-white/40">
              {description}
            </CardDescription>
          </div>
        </div>
      </CardHeader>
      <CardContent className="space-y-8">
        {/* Model Selection */}
        <div className="flex items-center gap-4">
          <Select
            value={selectedModel}
            onValueChange={handleModelChange}
            disabled={status === 'in_progress' || status === 'completed'}
          >
            <SelectTrigger className="glass glass-hover w-[200px]">
              <SelectValue placeholder="Select model" />
            </SelectTrigger>
            <SelectContent className="dark bg-background/90 backdrop-blur-lg border-white/10">
              <SelectItem value="deepseek-reasoner">DeepSeek Reasoner</SelectItem>
              <SelectItem value="gpt-4">GPT-4</SelectItem>
              <SelectItem value="gpt-4o-mini">GPT-4o-mini</SelectItem>
              <SelectItem value="o3-mini">o3-Mini</SelectItem>
            </SelectContent>
          </Select>
          {(status === 'pending' || status === 'error') && (
            <Button
              onClick={() => onStart(selectedModel)}
              className="button-glow-subtle bg-gradient-to-r from-blue-500/90 via-purple-500/90 to-pink-500/90 hover:from-blue-600/90 hover:via-purple-600/90 hover:to-pink-600/90 text-white shadow-lg group"
              disabled={!prompt}
            >
              <PlayCircle className="h-4 w-4 mr-2 transition-transform group-hover:-translate-y-0.5" />
              Start Analysis
            </Button>
          )}
        </div>

        {renderStatus()}

        {/* Analysis Results */}
        {status === 'completed' && result && (
          <div className="space-y-6">
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-blue-500/10 via-purple-500/10 to-pink-500/10 flex items-center justify-center">
                  <FileText className="h-4 w-4 text-blue-400/80" />
                </div>
                <h3 className="text-lg font-semibold bg-clip-text text-transparent bg-gradient-to-r from-blue-400/80 via-purple-400/80 to-pink-400/80">
                  Analysis Results
                </h3>
              </div>
              <div className="flex items-center gap-4">
                <Button
                  onClick={() => onStart(selectedModel)}
                  className="button-glow-subtle bg-gradient-to-r from-blue-500/80 via-purple-500/80 to-pink-500/80 hover:from-blue-600/80 hover:via-purple-600/80 hover:to-pink-600/80 text-white shadow-lg group"
                >
                  <RefreshCw className="h-4 w-4 mr-2 transition-transform group-hover:rotate-180" />
                  Rerun Analysis
                </Button>
                {result.metadata?.usage && (
                  <div className="text-sm text-muted-foreground/70 flex items-center gap-2">
                    <Code className="h-4 w-4" />
                    <span title="Total tokens used">{result.metadata.usage.total_tokens.toLocaleString()} tokens</span>
                  </div>
                )}
              </div>
            </div>
            <Card className="glass-subtle">
              <CardContent className="p-6">
                <ScrollArea className="h-[300px] overflow-y-auto pr-4" type="always">
                  <div className="space-y-6">
                    <div className="prose prose-invert max-w-none">
                      <div className="whitespace-pre-wrap text-white/80">{result.content}</div>
                    </div>
                    {result.metadata?.key_findings && result.metadata.key_findings.length > 0 && (
                      <div className="pt-4 border-t border-white/5">
                        <h4 className="text-lg font-semibold mb-3 bg-clip-text text-transparent bg-gradient-to-r from-blue-400/80 via-purple-400/80 to-pink-400/80">
                          Key Findings
                        </h4>
                        <ul className="list-none space-y-2">
                          {result.metadata.key_findings.map((finding, index) => (
                            <li key={index} className="flex items-start gap-3">
                              <div className="w-6 h-6 rounded-lg bg-gradient-to-br from-blue-500/10 via-purple-500/10 to-pink-500/10 flex items-center justify-center mt-0.5">
                                <span className="text-xs font-medium text-blue-400/80">{index + 1}</span>
                              </div>
                              <span className="text-white/60">{finding}</span>
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                  </div>
                </ScrollArea>
              </CardContent>
            </Card>

            {/* User Adjustments Section */}
            <div className="space-y-4">
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-3">
                  <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-blue-500/10 via-purple-500/10 to-pink-500/10 flex items-center justify-center">
                    <MessageSquare className="h-4 w-4 text-blue-400/80" />
                  </div>
                  <h3 className="text-lg font-semibold bg-clip-text text-transparent bg-gradient-to-r from-blue-400/80 via-purple-400/80 to-pink-400/80">
                    Adjustments & Comments
                  </h3>
                </div>
                <Button
                  onClick={() => handleAdjustment()}
                  className="button-glow-subtle bg-gradient-to-r from-blue-500/80 via-purple-500/80 to-pink-500/80 hover:from-blue-600/80 hover:via-purple-600/80 hover:to-pink-600/80 text-white shadow-lg group"
                  disabled={!adjustmentText.trim()}
                >
                  <RefreshCw className="h-4 w-4 mr-2 transition-transform group-hover:rotate-180" />
                  Apply Adjustments
                </Button>
              </div>
              
              <Card className="glass-subtle">
                <CardContent className="p-6">
                  <div className="space-y-4">
                    <p className="text-sm text-white/60">
                      Provide additional context, request specific focus areas, or suggest modifications to the analysis.
                      Your input will be used to refine and adjust the current results while maintaining the context.
                    </p>
                    <Textarea
                      placeholder={`Example prompts:
• Could you elaborate more on the technical aspects?
• Please focus more on the business impact.
• Can you rewrite this with a more strategic perspective?
• Add more specific examples related to...`}
                      value={adjustmentText}
                      onChange={(e) => setAdjustmentText(e.target.value)}
                      className="min-h-[120px] bg-background/30 border-white/10 focus:border-white/20 placeholder:text-white/20"
                    />
                    {isAdjusting && (
                      <div className="flex items-center gap-3 text-sm text-blue-400/90">
                        <Loader2 className="h-4 w-4 animate-spin" />
                        <span>Applying adjustments...</span>
                      </div>
                    )}
                  </div>
                </CardContent>
              </Card>
            </div>
          </div>
        )}

        {/* Debug Info */}
        <Collapsible>
          <CollapsibleTrigger asChild>
            <Button variant="outline" size="sm" className="flex items-center gap-2">
              <Code className="h-4 w-4" />
              Show Raw Prompt Data
            </Button>
          </CollapsibleTrigger>
          <CollapsibleContent>
            <Card className="mt-4 bg-background/50">
              <CardContent className="p-4">
                <pre className="text-sm text-muted-foreground whitespace-pre-wrap">
                  {JSON.stringify(prompt, null, 2)}
                </pre>
              </CardContent>
            </Card>
          </CollapsibleContent>
        </Collapsible>

        {/* Required Documents */}
        {documents && documents.length > 0 && (
          <div className="space-y-4">
            <h3 className="text-lg font-semibold">Required Documents</h3>
            <div className="grid gap-4 md:grid-cols-2">
              {documents.map((doc) => (
                <Card key={doc.id} className="bg-background/50">
                  <CardContent className="p-4 flex items-start gap-3">
                    <FileText className="h-5 w-5 text-blue-400 shrink-0 mt-0.5" />
                    <div className="font-medium">
                      {doc.filename}
                    </div>
                  </CardContent>
                </Card>
              ))}
            </div>
          </div>
        )}

        {/* Instructions */}
        {prompt && (
          <div className="space-y-4">
            <h3 className="text-lg font-semibold">Instructions</h3>
            <ScrollArea className="h-[200px] rounded-md border p-4">
              <div className="space-y-4">
                <p className="text-muted-foreground whitespace-pre-wrap">
                  {prompt.prompt}
                </p>
              </div>
            </ScrollArea>
          </div>
        )}
      </CardContent>
    </Card>
  );
} 